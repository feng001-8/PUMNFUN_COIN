import { logger } from '../utils/logger.js';
import { enhancedErrorHandler } from '../utils/enhanced-error-handler.js';
export class KOLTracker {
    db;
    io;
    isRunning = false;
    monitoredKOLs = new Set();
    constructor(db) {
        this.db = db;
        logger.info('üéØ KOLËøΩË∏™Âô®Â∑≤ÂàùÂßãÂåñ');
    }
    setSocketIO(io) {
        this.io = io;
    }
    async start() {
        if (this.isRunning)
            return;
        this.isRunning = true;
        try {
            // Âä†ËΩΩÊ¥ªË∑ÉÁöÑKOLÂàóË°®
            await this.loadActiveKOLs();
            // ÂàùÂßãÂåñ‰∏Ä‰∫õÁü•ÂêçKOLÊï∞ÊçÆÔºàÁ§∫‰æãÔºâ
            await this.initializeDefaultKOLs();
            logger.info('üéØ KOLËøΩË∏™Âô®ÂêØÂä®ÂÆåÊàê');
            // ÂÆöÊúüÊõ¥Êñ∞KOLÁªüËÆ°Êï∞ÊçÆ
            setInterval(() => {
                this.updateKOLStatistics().catch(error => {
                    enhancedErrorHandler.handleError(error, 'updateKOLStatisticsÂÆöÊó∂‰ªªÂä°');
                });
            }, 300000); // ÊØè5ÂàÜÈíüÊõ¥Êñ∞‰∏ÄÊ¨°
        }
        catch (error) {
            await enhancedErrorHandler.handleError(error, 'KOLËøΩË∏™Âô®ÂêØÂä®');
            throw error;
        }
    }
    async stop() {
        this.isRunning = false;
        logger.info('üõë KOLËøΩË∏™Âô®ÂÅúÊ≠¢');
    }
    // Ê∑ªÂä†KOLÂà∞ÁõëÊéßÂàóË°®
    async addKOL(kolInfo) {
        const db = this.db.getDb();
        try {
            const stmt = db.prepare(`
        INSERT INTO kol_info (
          wallet_address, name, category, influence_score, success_rate,
          total_trades, profitable_trades, avg_profit_rate, followers_count,
          verified, tags, social_links, is_active
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `);
            const result = stmt.run(kolInfo.walletAddress, kolInfo.name, kolInfo.category, kolInfo.influenceScore, kolInfo.successRate, kolInfo.totalTrades, kolInfo.profitableTrades, kolInfo.avgProfitRate, kolInfo.followersCount, kolInfo.verified ? 1 : 0, JSON.stringify(kolInfo.tags), JSON.stringify(kolInfo.socialLinks), kolInfo.isActive ? 1 : 0);
            this.monitoredKOLs.add(kolInfo.walletAddress);
            logger.info(`‚úÖ Â∑≤Ê∑ªÂä†KOLÂà∞ÁõëÊéßÂàóË°®: ${kolInfo.name} (${kolInfo.walletAddress})`);
            return result.lastInsertRowid;
        }
        catch (error) {
            await enhancedErrorHandler.handleError(error, 'addKOL', { walletAddress: kolInfo.walletAddress });
            throw error;
        }
    }
    // ËÆ∞ÂΩïKOL‰∫§Êòì
    async recordKOLTransaction(transaction) {
        const db = this.db.getDb();
        try {
            // Ê£ÄÊü•ÊòØÂê¶ÊòØÁõëÊéßÁöÑKOL
            if (!this.monitoredKOLs.has(transaction.kolWalletAddress)) {
                return; // ‰∏çÊòØÁõëÊéßÁöÑKOLÔºåÂøΩÁï•
            }
            const stmt = db.prepare(`
        INSERT INTO kol_transactions (
          kol_wallet_address, token_address, transaction_hash, action,
          amount, price, value_sol, timestamp, profit_loss, holding_period
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `);
            stmt.run(transaction.kolWalletAddress, transaction.tokenAddress, transaction.transactionHash, transaction.action, transaction.amount, transaction.price, transaction.valueSol, transaction.timestamp.toISOString(), transaction.profitLoss || null, transaction.holdingPeriod || null);
            // ÁîüÊàêKOL‰ø°Âè∑
            await this.generateKOLSignal(transaction);
            logger.info(`üìä ËÆ∞ÂΩïKOL‰∫§Êòì: ${transaction.action} ${transaction.amount} tokens`);
        }
        catch (error) {
            await enhancedErrorHandler.handleError(error, 'recordKOLTransaction', { kolWallet: transaction.kolWalletAddress, tokenAddress: transaction.tokenAddress });
        }
    }
    // ÁîüÊàêKOL‰ø°Âè∑
    async generateKOLSignal(transaction) {
        try {
            // Ëé∑ÂèñKOL‰ø°ÊÅØ
            const kolInfo = await this.getKOLInfo(transaction.kolWalletAddress);
            if (!kolInfo)
                return;
            // Ëé∑Âèñ‰ª£Â∏Å‰ø°ÊÅØ
            const tokenInfo = await this.getTokenInfo(transaction.tokenAddress);
            if (!tokenInfo)
                return;
            // ËÆ°ÁÆó‰ø°Âè∑ÁΩÆ‰ø°Â∫¶
            const confidence = this.calculateSignalConfidence(kolInfo, transaction);
            // ÁîüÊàêÊé®ÁêÜËØ¥Êòé
            const reasoning = this.generateSignalReasoning(kolInfo, transaction);
            const signal = {
                kolWalletAddress: transaction.kolWalletAddress,
                kolName: kolInfo.name || 'Unknown KOL',
                tokenAddress: transaction.tokenAddress,
                tokenSymbol: tokenInfo.symbol,
                action: transaction.action,
                amount: transaction.amount,
                price: transaction.price,
                valueSol: transaction.valueSol,
                confidence,
                reasoning,
                timestamp: transaction.timestamp
            };
            // ÂπøÊí≠KOL‰ø°Âè∑
            if (this.io && confidence >= 70) { // Âè™ÂπøÊí≠È´òÁΩÆ‰ø°Â∫¶‰ø°Âè∑
                this.io.emit('kol_signal', signal);
                logger.info(`üéØ ÂπøÊí≠KOL‰ø°Âè∑: ${signal.kolName} ${signal.action} ${signal.tokenSymbol}`);
            }
        }
        catch (error) {
            await enhancedErrorHandler.handleError(error, 'generateKOLSignal');
        }
    }
    // ËÆ°ÁÆó‰ø°Âè∑ÁΩÆ‰ø°Â∫¶
    calculateSignalConfidence(kolInfo, transaction) {
        let confidence = 50; // Âü∫Á°ÄÁΩÆ‰ø°Â∫¶
        // Âü∫‰∫éKOLÂΩ±ÂìçÂäõËØÑÂàÜ
        confidence += kolInfo.influenceScore * 0.3;
        // Âü∫‰∫éÊàêÂäüÁéá
        confidence += kolInfo.successRate * 0.2;
        // Âü∫‰∫é‰∫§ÊòìÈáëÈ¢ùÔºàÂ§ßÈ¢ù‰∫§ÊòìÊõ¥Êúâ‰ø°Âè∑‰ª∑ÂÄºÔºâ
        if (transaction.valueSol > 100)
            confidence += 10;
        else if (transaction.valueSol > 50)
            confidence += 5;
        // Âü∫‰∫éÈ™åËØÅÁä∂ÊÄÅ
        if (kolInfo.verified)
            confidence += 10;
        // Âü∫‰∫éKOLÁ±ªÂà´
        if (kolInfo.category === 'trader')
            confidence += 5;
        else if (kolInfo.category === 'institution')
            confidence += 15;
        return Math.min(100, Math.max(0, confidence));
    }
    // ÁîüÊàê‰ø°Âè∑Êé®ÁêÜËØ¥Êòé
    generateSignalReasoning(kolInfo, transaction) {
        const reasons = [];
        if (kolInfo.influenceScore > 80) {
            reasons.push('È´òÂΩ±ÂìçÂäõKOL');
        }
        if (kolInfo.successRate > 70) {
            reasons.push(`ÂéÜÂè≤ÊàêÂäüÁéá${kolInfo.successRate.toFixed(1)}%`);
        }
        if (kolInfo.verified) {
            reasons.push('Â∑≤È™åËØÅË∫´‰ªΩ');
        }
        if (transaction.valueSol > 100) {
            reasons.push('Â§ßÈ¢ù‰∫§Êòì');
        }
        if (kolInfo.category === 'institution') {
            reasons.push('Êú∫ÊûÑÊäïËµÑËÄÖ');
        }
        return reasons.join('Ôºå') || 'Â∏∏ËßÑ‰∫§Êòì‰ø°Âè∑';
    }
    // Ëé∑ÂèñKOL‰ø°ÊÅØ
    async getKOLInfo(walletAddress) {
        const db = this.db.getDb();
        try {
            const stmt = db.prepare(`
        SELECT * FROM kol_info WHERE wallet_address = ? AND is_active = 1
      `);
            const row = stmt.get(walletAddress);
            if (!row)
                return null;
            return {
                id: row.id,
                walletAddress: row.wallet_address,
                name: row.name,
                category: row.category,
                influenceScore: row.influence_score,
                successRate: row.success_rate,
                totalTrades: row.total_trades,
                profitableTrades: row.profitable_trades,
                avgProfitRate: row.avg_profit_rate,
                followersCount: row.followers_count,
                verified: row.verified === 1,
                tags: JSON.parse(row.tags || '[]'),
                socialLinks: JSON.parse(row.social_links || '{}'),
                isActive: row.is_active === 1,
                createdAt: new Date(row.created_at),
                updatedAt: new Date(row.updated_at)
            };
        }
        catch (error) {
            await enhancedErrorHandler.handleError(error, 'getKOLInfo', { walletAddress });
            return null;
        }
    }
    // Ëé∑Âèñ‰ª£Â∏Å‰ø°ÊÅØ
    async getTokenInfo(tokenAddress) {
        const db = this.db.getDb();
        try {
            const stmt = db.prepare(`
        SELECT symbol, name FROM tokens WHERE address = ?
      `);
            const row = stmt.get(tokenAddress);
            return row ? { symbol: row.symbol, name: row.name } : null;
        }
        catch (error) {
            return null;
        }
    }
    // Âä†ËΩΩÊ¥ªË∑ÉÁöÑKOLÂàóË°®
    async loadActiveKOLs() {
        const db = this.db.getDb();
        try {
            const stmt = db.prepare(`
        SELECT wallet_address FROM kol_info WHERE is_active = 1
      `);
            const rows = stmt.all();
            this.monitoredKOLs.clear();
            rows.forEach(row => {
                this.monitoredKOLs.add(row.wallet_address);
            });
            logger.info(`üìã Âä†ËΩΩ‰∫Ü ${this.monitoredKOLs.size} ‰∏™Ê¥ªË∑ÉKOL`);
        }
        catch (error) {
            await enhancedErrorHandler.handleError(error, 'loadActiveKOLs');
        }
    }
    // ÂàùÂßãÂåñÈªòËÆ§KOLÊï∞ÊçÆ
    async initializeDefaultKOLs() {
        const defaultKOLs = [
            {
                walletAddress: '7BgBvyjrZX1YKz4oh9mjb8ZScatkkwb8DzFx6LnRTsAD',
                name: 'Solana Whale #1',
                category: 'trader',
                influenceScore: 85,
                successRate: 72.5,
                totalTrades: 156,
                profitableTrades: 113,
                avgProfitRate: 45.2,
                followersCount: 0,
                verified: false,
                tags: ['whale', 'early-adopter', 'defi'],
                socialLinks: {},
                isActive: true
            },
            {
                walletAddress: '9WzDXwBbmkg8ZTbNMqUxvQRAyrZzDsGYdLVL9zYtAWWM',
                name: 'PumpFun Expert',
                category: 'influencer',
                influenceScore: 78,
                successRate: 68.3,
                totalTrades: 89,
                profitableTrades: 61,
                avgProfitRate: 38.7,
                followersCount: 15000,
                verified: true,
                tags: ['pumpfun', 'meme-coins', 'alpha'],
                socialLinks: {
                    twitter: 'https://twitter.com/pumpfun_expert'
                },
                isActive: true
            }
        ];
        for (const kol of defaultKOLs) {
            try {
                // Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú®
                const existing = await this.getKOLInfo(kol.walletAddress);
                if (!existing) {
                    await this.addKOL(kol);
                }
            }
            catch (error) {
                // ÂøΩÁï•ÈáçÂ§çÊ∑ªÂä†ÈîôËØØ
                logger.debug(`Ë∑≥ËøáÂ∑≤Â≠òÂú®ÁöÑKOL: ${kol.walletAddress}`);
            }
        }
    }
    // Êõ¥Êñ∞KOLÁªüËÆ°Êï∞ÊçÆ
    async updateKOLStatistics() {
        const db = this.db.getDb();
        try {
            // Ëé∑ÂèñÊâÄÊúâÊ¥ªË∑ÉKOL
            const kolStmt = db.prepare(`
        SELECT wallet_address FROM kol_info WHERE is_active = 1
      `);
            const kols = kolStmt.all();
            for (const kol of kols) {
                // ËÆ°ÁÆó‰∫§ÊòìÁªüËÆ°
                const statsStmt = db.prepare(`
          SELECT 
            COUNT(*) as total_trades,
            SUM(CASE WHEN profit_loss > 0 THEN 1 ELSE 0 END) as profitable_trades,
            AVG(CASE WHEN profit_loss IS NOT NULL THEN profit_loss ELSE 0 END) as avg_profit
          FROM kol_transactions 
          WHERE kol_wallet_address = ?
        `);
                const stats = statsStmt.get(kol.wallet_address);
                if (stats && stats.total_trades > 0) {
                    const successRate = (stats.profitable_trades / stats.total_trades) * 100;
                    // Êõ¥Êñ∞KOLÁªüËÆ°‰ø°ÊÅØ
                    const updateStmt = db.prepare(`
            UPDATE kol_info 
            SET 
              total_trades = ?,
              profitable_trades = ?,
              success_rate = ?,
              avg_profit_rate = ?,
              updated_at = CURRENT_TIMESTAMP
            WHERE wallet_address = ?
          `);
                    updateStmt.run(stats.total_trades, stats.profitable_trades, successRate, stats.avg_profit || 0, kol.wallet_address);
                }
            }
            logger.debug('üìä KOLÁªüËÆ°Êï∞ÊçÆÊõ¥Êñ∞ÂÆåÊàê');
        }
        catch (error) {
            await enhancedErrorHandler.handleError(error, 'updateKOLStatistics');
        }
    }
    // Ëé∑ÂèñÊâÄÊúâKOLÂàóË°®
    async getAllKOLs(limit = 50, offset = 0) {
        const db = this.db.getDb();
        try {
            const stmt = db.prepare(`
        SELECT * FROM kol_info 
        WHERE is_active = 1 
        ORDER BY influence_score DESC, success_rate DESC
        LIMIT ? OFFSET ?
      `);
            const rows = stmt.all(limit, offset);
            return rows.map(row => ({
                id: row.id,
                walletAddress: row.wallet_address,
                name: row.name,
                category: row.category,
                influenceScore: row.influence_score,
                successRate: row.success_rate,
                totalTrades: row.total_trades,
                profitableTrades: row.profitable_trades,
                avgProfitRate: row.avg_profit_rate,
                followersCount: row.followers_count,
                verified: row.verified === 1,
                tags: JSON.parse(row.tags || '[]'),
                socialLinks: JSON.parse(row.social_links || '{}'),
                isActive: row.is_active === 1,
                createdAt: new Date(row.created_at),
                updatedAt: new Date(row.updated_at)
            }));
        }
        catch (error) {
            await enhancedErrorHandler.handleError(error, 'getAllKOLs');
            return [];
        }
    }
    // Ëé∑ÂèñKOL‰∫§ÊòìËÆ∞ÂΩï
    async getKOLTransactions(walletAddress, limit = 50) {
        const db = this.db.getDb();
        try {
            const stmt = db.prepare(`
        SELECT * FROM kol_transactions 
        WHERE kol_wallet_address = ? 
        ORDER BY timestamp DESC
        LIMIT ?
      `);
            const rows = stmt.all(walletAddress, limit);
            return rows.map(row => ({
                id: row.id,
                kolWalletAddress: row.kol_wallet_address,
                tokenAddress: row.token_address,
                transactionHash: row.transaction_hash,
                action: row.action,
                amount: row.amount,
                price: row.price,
                valueSol: row.value_sol,
                timestamp: new Date(row.timestamp),
                profitLoss: row.profit_loss,
                holdingPeriod: row.holding_period,
                createdAt: new Date(row.created_at)
            }));
        }
        catch (error) {
            await enhancedErrorHandler.handleError(error, 'getKOLTransactions', { walletAddress });
            return [];
        }
    }
}
//# sourceMappingURL=kol-tracker.js.map