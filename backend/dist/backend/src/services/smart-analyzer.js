import { logger } from '../utils/logger.js';
import { enhancedErrorHandler } from '../utils/enhanced-error-handler.js';
export class SmartAnalyzer {
    db;
    io;
    kolTracker;
    sentimentAnalyzer;
    isRunning = false;
    analysisInterval;
    constructor(db) {
        this.db = db;
        logger.info('üß† Êô∫ËÉΩÂàÜÊûêÂºïÊìéÂ∑≤ÂàùÂßãÂåñ');
    }
    setSocketIO(io) {
        this.io = io;
    }
    setKOLTracker(kolTracker) {
        this.kolTracker = kolTracker;
    }
    setSentimentAnalyzer(sentimentAnalyzer) {
        this.sentimentAnalyzer = sentimentAnalyzer;
    }
    async start() {
        if (this.isRunning)
            return;
        this.isRunning = true;
        try {
            // ÂàùÂßãÂåñÊäÄÊúØÊåáÊ†áÊï∞ÊçÆ
            await this.initializeTechnicalIndicators();
            logger.info('üß† Êô∫ËÉΩÂàÜÊûêÂºïÊìéÂêØÂä®ÂÆåÊàê');
            // ÂÆöÊúüÊâßË°åÊô∫ËÉΩÂàÜÊûê
            this.analysisInterval = setInterval(() => {
                this.performSmartAnalysis().catch(error => {
                    enhancedErrorHandler.handleError(error, 'Êô∫ËÉΩÂàÜÊûêÂÆöÊó∂‰ªªÂä°');
                });
            }, 120000); // ÊØè2ÂàÜÈíüÂàÜÊûê‰∏ÄÊ¨°
        }
        catch (error) {
            await enhancedErrorHandler.handleError(error, 'Êô∫ËÉΩÂàÜÊûêÂºïÊìéÂêØÂä®');
            throw error;
        }
    }
    async stop() {
        this.isRunning = false;
        if (this.analysisInterval) {
            clearInterval(this.analysisInterval);
        }
        logger.info('üõë Êô∫ËÉΩÂàÜÊûêÂºïÊìéÂÅúÊ≠¢');
    }
    // ÊâßË°åÊô∫ËÉΩÂàÜÊûê
    async performSmartAnalysis() {
        try {
            // Ëé∑ÂèñÊ¥ªË∑É‰ª£Â∏ÅÂàóË°®
            const activeTokens = await this.getActiveTokens(10);
            for (const token of activeTokens) {
                const analysis = await this.analyzeToken(token.address);
                if (analysis) {
                    // ÂπøÊí≠ÂàÜÊûêÁªìÊûú
                    if (this.io) {
                        this.io.emit('smart_analysis', analysis);
                    }
                    // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÁîüÊàêÈ¢ÑË≠¶
                    await this.checkAnalysisAlerts(analysis);
                }
            }
            logger.debug('üß† Êô∫ËÉΩÂàÜÊûêÂë®ÊúüÂÆåÊàê');
        }
        catch (error) {
            await enhancedErrorHandler.handleError(error, 'performSmartAnalysis');
        }
    }
    // ÂàÜÊûêÂçï‰∏™‰ª£Â∏Å
    async analyzeToken(tokenAddress) {
        try {
            // Ëé∑Âèñ‰ª£Â∏ÅÂü∫Êú¨‰ø°ÊÅØ
            const tokenInfo = await this.getTokenInfo(tokenAddress);
            if (!tokenInfo)
                return null;
            // Ëé∑ÂèñÂêÑÁª¥Â∫¶ÂàÜÊûêÊï∞ÊçÆ
            const technicalAnalysis = await this.performTechnicalAnalysis(tokenAddress);
            const sentimentAnalysis = await this.getSentimentAnalysis(tokenAddress);
            const kolAnalysis = await this.performKOLAnalysis(tokenAddress);
            const marketAnalysis = await this.performMarketAnalysis(tokenAddress);
            // ËÆ°ÁÆóÁªºÂêàËØÑÂàÜ
            const overallScore = this.calculateOverallScore(technicalAnalysis, sentimentAnalysis, kolAnalysis, marketAnalysis);
            // ËÆ°ÁÆóÈ£éÈô©ËØÑÂàÜ
            const riskScore = this.calculateRiskScore(technicalAnalysis, sentimentAnalysis, marketAnalysis);
            // ËÆ°ÁÆóÊΩúÂäõËØÑÂàÜ
            const potentialScore = this.calculatePotentialScore(technicalAnalysis, sentimentAnalysis, kolAnalysis, marketAnalysis);
            // ÁîüÊàêÊäïËµÑÂª∫ËÆÆ
            const recommendation = this.generateRecommendation(overallScore, riskScore, potentialScore, technicalAnalysis, sentimentAnalysis, marketAnalysis);
            // ÁîüÊàê‰ª∑Ê†ºÈ¢ÑÊµã
            const prediction = this.generatePricePrediction(tokenAddress, technicalAnalysis, sentimentAnalysis, marketAnalysis);
            const analysis = {
                tokenAddress,
                tokenSymbol: tokenInfo.symbol,
                tokenName: tokenInfo.name,
                overallScore,
                riskScore,
                potentialScore,
                technicalAnalysis,
                sentimentAnalysis,
                kolAnalysis,
                marketAnalysis,
                recommendation,
                prediction,
                timestamp: new Date(),
                lastUpdated: new Date()
            };
            return analysis;
        }
        catch (error) {
            await enhancedErrorHandler.handleError(error, 'analyzeToken', { tokenAddress });
            return null;
        }
    }
    // ÊâßË°åÊäÄÊúØÂàÜÊûê
    async performTechnicalAnalysis(tokenAddress) {
        try {
            // Ëé∑Âèñ‰ª∑Ê†ºÊï∞ÊçÆ
            const priceData = await this.getPriceData(tokenAddress, 100);
            // ËÆ°ÁÆóÊäÄÊúØÊåáÊ†á
            const indicators = await this.calculateTechnicalIndicators(tokenAddress, priceData);
            // ÂàÜÊûêË∂ãÂäø
            const trend = this.analyzeTrend(priceData);
            // ËÆ°ÁÆóÊîØÊíë‰ΩçÂíåÈòªÂäõ‰Ωç
            const { support, resistance } = this.calculateSupportResistance(priceData);
            // ÁîüÊàêÊäÄÊúØ‰ø°Âè∑
            const signals = this.generateTechnicalSignals(indicators, trend);
            // ËÆ°ÁÆóÊäÄÊúØÂàÜÊûêËØÑÂàÜ
            const score = this.calculateTechnicalScore(indicators, trend, signals);
            return {
                score,
                signals,
                indicators,
                trend,
                support,
                resistance
            };
        }
        catch (error) {
            logger.error('ÊäÄÊúØÂàÜÊûêÂ§±Ë¥•:', error);
            return {
                score: 50,
                signals: ['Êï∞ÊçÆ‰∏çË∂≥'],
                indicators: [],
                trend: 'neutral',
                support: 0,
                resistance: 0
            };
        }
    }
    // Ëé∑ÂèñÊÉÖÁª™ÂàÜÊûê
    async getSentimentAnalysis(tokenAddress) {
        try {
            if (!this.sentimentAnalyzer) {
                return {
                    score: 50,
                    sentiment: 'neutral',
                    confidence: 0,
                    socialVolume: 0,
                    keySignals: ['ÊÉÖÁª™ÂàÜÊûêÊúçÂä°Êú™ÂêØÁî®']
                };
            }
            const analysis = await this.sentimentAnalyzer.analyzeTokenSentiment(tokenAddress);
            if (!analysis) {
                return {
                    score: 50,
                    sentiment: 'neutral',
                    confidence: 0,
                    socialVolume: 0,
                    keySignals: ['ÊöÇÊó†ÊÉÖÁª™Êï∞ÊçÆ']
                };
            }
            return {
                score: (analysis.sentimentScore + 100) / 2, // ËΩ¨Êç¢‰∏∫0-100ËåÉÂõ¥
                sentiment: analysis.overallSentiment,
                confidence: analysis.confidence,
                socialVolume: analysis.socialVolume,
                keySignals: analysis.keySignals
            };
        }
        catch (error) {
            logger.error('Ëé∑ÂèñÊÉÖÁª™ÂàÜÊûêÂ§±Ë¥•:', error);
            return {
                score: 50,
                sentiment: 'neutral',
                confidence: 0,
                socialVolume: 0,
                keySignals: ['ÊÉÖÁª™ÂàÜÊûêÈîôËØØ']
            };
        }
    }
    // ÊâßË°åKOLÂàÜÊûê
    async performKOLAnalysis(tokenAddress) {
        try {
            if (!this.kolTracker) {
                return {
                    score: 50,
                    activeKOLs: 0,
                    recentActivity: ['KOLËøΩË∏™ÊúçÂä°Êú™ÂêØÁî®'],
                    influenceLevel: 'low'
                };
            }
            // Ëé∑ÂèñÊúÄËøë24Â∞èÊó∂ÁöÑKOL‰∫§Êòì
            const recentTransactions = await this.getRecentKOLTransactions(tokenAddress, 24);
            // ÂàÜÊûêKOLÊ¥ªÂä®
            const activeKOLs = new Set(recentTransactions.map(tx => tx.kolWalletAddress)).size;
            const recentActivity = this.analyzeKOLActivity(recentTransactions);
            const influenceLevel = this.calculateInfluenceLevel(recentTransactions);
            const score = this.calculateKOLScore(activeKOLs, recentTransactions, influenceLevel);
            return {
                score,
                activeKOLs,
                recentActivity,
                influenceLevel
            };
        }
        catch (error) {
            logger.error('KOLÂàÜÊûêÂ§±Ë¥•:', error);
            return {
                score: 50,
                activeKOLs: 0,
                recentActivity: ['KOLÂàÜÊûêÈîôËØØ'],
                influenceLevel: 'low'
            };
        }
    }
    // ÊâßË°åÂ∏ÇÂú∫ÂàÜÊûê
    async performMarketAnalysis(tokenAddress) {
        try {
            const db = this.db.getDb();
            // Ëé∑Âèñ24Â∞èÊó∂‰∫§ÊòìÊï∞ÊçÆ
            const tradingStmt = db.prepare(`
        SELECT 
          SUM(volume) as volume24h,
          AVG(price) as avgPrice,
          MIN(price) as minPrice,
          MAX(price) as maxPrice,
          COUNT(*) as tradeCount
        FROM trading_data 
        WHERE token_address = ? 
        AND timestamp > datetime('now', '-24 hours')
      `);
            const tradingData = tradingStmt.get(tokenAddress);
            // Ëé∑ÂèñÂΩìÂâç‰ª∑Ê†º
            const priceStmt = db.prepare(`
        SELECT price FROM price_data 
        WHERE token_address = ? 
        ORDER BY timestamp DESC 
        LIMIT 1
      `);
            const currentPriceData = priceStmt.get(tokenAddress);
            const currentPrice = currentPriceData?.price || 0;
            // Ëé∑Âèñ24Â∞èÊó∂Ââç‰ª∑Ê†º
            const oldPriceStmt = db.prepare(`
        SELECT price FROM price_data 
        WHERE token_address = ? 
        AND timestamp <= datetime('now', '-24 hours')
        ORDER BY timestamp DESC 
        LIMIT 1
      `);
            const oldPriceData = oldPriceStmt.get(tokenAddress);
            const oldPrice = oldPriceData?.price || currentPrice;
            // ËÆ°ÁÆó‰ª∑Ê†ºÂèòÂåñ
            const priceChange24h = oldPrice > 0 ? ((currentPrice - oldPrice) / oldPrice) * 100 : 0;
            // ËÆ°ÁÆóÊ≥¢Âä®Áéá
            const volatility = tradingData?.maxPrice && tradingData?.minPrice
                ? ((tradingData.maxPrice - tradingData.minPrice) / tradingData.avgPrice) * 100
                : 0;
            // ‰º∞ÁÆóÂ∏ÇÂÄºÂíåÊµÅÂä®ÊÄßÔºàÁÆÄÂåñËÆ°ÁÆóÔºâ
            const marketCap = currentPrice * 1000000; // ÂÅáËÆæ‰æõÂ∫îÈáè
            const liquidity = tradingData?.volume24h || 0;
            // ËÆ°ÁÆóÂ∏ÇÂú∫ÂàÜÊûêËØÑÂàÜ
            const score = this.calculateMarketScore(tradingData?.volume24h || 0, priceChange24h, volatility, liquidity);
            return {
                score,
                volume24h: tradingData?.volume24h || 0,
                priceChange24h,
                marketCap,
                liquidity,
                volatility
            };
        }
        catch (error) {
            logger.error('Â∏ÇÂú∫ÂàÜÊûêÂ§±Ë¥•:', error);
            return {
                score: 50,
                volume24h: 0,
                priceChange24h: 0,
                marketCap: 0,
                liquidity: 0,
                volatility: 0
            };
        }
    }
    // ËÆ°ÁÆóÁªºÂêàËØÑÂàÜ
    calculateOverallScore(technical, sentiment, kol, market) {
        // ÊùÉÈáçÂàÜÈÖç
        const weights = {
            technical: 0.3,
            sentiment: 0.25,
            kol: 0.2,
            market: 0.25
        };
        const weightedScore = technical.score * weights.technical +
            sentiment.score * weights.sentiment +
            kol.score * weights.kol +
            market.score * weights.market;
        return Math.round(weightedScore);
    }
    // ËÆ°ÁÆóÈ£éÈô©ËØÑÂàÜ
    calculateRiskScore(technical, sentiment, market) {
        let riskScore = 50; // Âü∫Á°ÄÈ£éÈô©
        // ÊäÄÊúØÈ£éÈô©
        if (technical.trend === 'bearish')
            riskScore += 15;
        if (technical.signals.some(s => s.includes('ÂçñÂá∫')))
            riskScore += 10;
        // ÊÉÖÁª™È£éÈô©
        if (sentiment.sentiment.includes('bearish'))
            riskScore += 15;
        if (sentiment.confidence < 50)
            riskScore += 10;
        // Â∏ÇÂú∫È£éÈô©
        if (market.volatility > 50)
            riskScore += 20;
        if (market.volume24h < 1000)
            riskScore += 15;
        if (market.priceChange24h < -20)
            riskScore += 25;
        return Math.min(100, Math.max(0, riskScore));
    }
    // ËÆ°ÁÆóÊΩúÂäõËØÑÂàÜ
    calculatePotentialScore(technical, sentiment, kol, market) {
        let potentialScore = 50; // Âü∫Á°ÄÊΩúÂäõ
        // ÊäÄÊúØÊΩúÂäõ
        if (technical.trend === 'bullish')
            potentialScore += 15;
        if (technical.signals.some(s => s.includes('‰π∞ÂÖ•')))
            potentialScore += 10;
        // ÊÉÖÁª™ÊΩúÂäõ
        if (sentiment.sentiment.includes('bullish'))
            potentialScore += 15;
        if (sentiment.socialVolume > 70)
            potentialScore += 10;
        // KOLÊΩúÂäõ
        if (kol.influenceLevel === 'high')
            potentialScore += 20;
        if (kol.activeKOLs > 3)
            potentialScore += 10;
        // Â∏ÇÂú∫ÊΩúÂäõ
        if (market.priceChange24h > 20)
            potentialScore += 15;
        if (market.volume24h > 10000)
            potentialScore += 10;
        return Math.min(100, Math.max(0, potentialScore));
    }
    // ÁîüÊàêÊäïËµÑÂª∫ËÆÆ
    generateRecommendation(overallScore, riskScore, potentialScore, technical, sentiment, market) {
        let action = 'hold';
        let confidence = 50;
        const reasoning = [];
        const riskFactors = [];
        // Âü∫‰∫éÁªºÂêàËØÑÂàÜÂÜ≥ÂÆöË°åÂä®
        if (overallScore >= 80 && riskScore <= 40) {
            action = 'strong_buy';
            confidence = 85;
            reasoning.push('ÁªºÂêàËØÑÂàÜ‰ºòÁßÄÔºåÈ£éÈô©ÂèØÊéß');
        }
        else if (overallScore >= 65 && riskScore <= 60) {
            action = 'buy';
            confidence = 70;
            reasoning.push('ÁªºÂêàËØÑÂàÜËâØÂ•Ω');
        }
        else if (overallScore <= 35 || riskScore >= 80) {
            action = 'sell';
            confidence = 75;
            reasoning.push('ÁªºÂêàËØÑÂàÜËæÉ‰ΩéÊàñÈ£éÈô©ËøáÈ´ò');
        }
        else if (overallScore <= 20 || riskScore >= 90) {
            action = 'strong_sell';
            confidence = 85;
            reasoning.push('ÁªºÂêàËØÑÂàÜÂæà‰ΩéÔºåÈ£éÈô©ÊûÅÈ´ò');
        }
        // Ê∑ªÂä†ÂÖ∑‰ΩìÂàÜÊûêÂéüÂõ†
        if (technical.trend === 'bullish') {
            reasoning.push('ÊäÄÊúØÈù¢ÁúãÊ∂®');
        }
        else if (technical.trend === 'bearish') {
            reasoning.push('ÊäÄÊúØÈù¢ÁúãË∑å');
        }
        if (sentiment.sentiment.includes('bullish')) {
            reasoning.push('Â∏ÇÂú∫ÊÉÖÁª™ÁßØÊûÅ');
        }
        else if (sentiment.sentiment.includes('bearish')) {
            reasoning.push('Â∏ÇÂú∫ÊÉÖÁª™Ê∂àÊûÅ');
        }
        // Ê∑ªÂä†È£éÈô©Âõ†Á¥†
        if (market.volatility > 50) {
            riskFactors.push('‰ª∑Ê†ºÊ≥¢Âä®ËæÉÂ§ß');
        }
        if (market.volume24h < 1000) {
            riskFactors.push('‰∫§ÊòìÈáèÂÅè‰Ωé');
        }
        if (sentiment.confidence < 50) {
            riskFactors.push('ÊÉÖÁª™ÂàÜÊûêÁΩÆ‰ø°Â∫¶‰Ωé');
        }
        // Á°ÆÂÆöÊó∂Èó¥ËåÉÂõ¥
        let timeHorizon = 'medium';
        if (market.volatility > 70) {
            timeHorizon = 'short';
        }
        else if (potentialScore > 80) {
            timeHorizon = 'long';
        }
        return {
            action,
            confidence,
            reasoning: reasoning.length > 0 ? reasoning : ['Âü∫‰∫éÁªºÂêàÂàÜÊûê'],
            riskFactors: riskFactors.length > 0 ? riskFactors : ['Â∏∏ËßÑÂ∏ÇÂú∫È£éÈô©'],
            timeHorizon
        };
    }
    // ÁîüÊàê‰ª∑Ê†ºÈ¢ÑÊµã
    generatePricePrediction(tokenAddress, technical, sentiment, market) {
        // Ëé∑ÂèñÂΩìÂâç‰ª∑Ê†º
        const currentPrice = this.getCurrentPrice(tokenAddress);
        // Âü∫‰∫éÂêÑÁßçÂõ†Á¥†ËÆ°ÁÆó‰ª∑Ê†ºÂèòÂåñÈ¢ÑÊúü
        let priceChangeExpectation = 0;
        // ÊäÄÊúØÈù¢ÂΩ±Âìç
        if (technical.trend === 'bullish')
            priceChangeExpectation += 0.1;
        else if (technical.trend === 'bearish')
            priceChangeExpectation -= 0.1;
        // ÊÉÖÁª™Èù¢ÂΩ±Âìç
        if (sentiment.sentiment.includes('bullish'))
            priceChangeExpectation += 0.08;
        else if (sentiment.sentiment.includes('bearish'))
            priceChangeExpectation -= 0.08;
        // Â∏ÇÂú∫Èù¢ÂΩ±Âìç
        if (market.priceChange24h > 0)
            priceChangeExpectation += market.priceChange24h / 1000;
        // Ê≥¢Âä®ÁéáÂΩ±Âìç
        const volatilityFactor = market.volatility / 100;
        return {
            priceTarget1h: currentPrice * (1 + priceChangeExpectation * 0.1 + Math.random() * volatilityFactor * 0.1),
            priceTarget24h: currentPrice * (1 + priceChangeExpectation * 0.5 + Math.random() * volatilityFactor * 0.2),
            priceTarget7d: currentPrice * (1 + priceChangeExpectation * 2 + Math.random() * volatilityFactor * 0.5),
            probability: Math.max(30, Math.min(90, 60 + sentiment.confidence * 0.3)),
            scenarios: {
                bullish: {
                    probability: sentiment.sentiment.includes('bullish') ? 40 : 25,
                    target: currentPrice * (1 + Math.abs(priceChangeExpectation) * 3)
                },
                neutral: {
                    probability: 35,
                    target: currentPrice * (1 + priceChangeExpectation * 0.1)
                },
                bearish: {
                    probability: sentiment.sentiment.includes('bearish') ? 40 : 25,
                    target: currentPrice * (1 - Math.abs(priceChangeExpectation) * 2)
                }
            }
        };
    }
    // ËæÖÂä©ÊñπÊ≥ïÂÆûÁé∞...
    async getPriceData(tokenAddress, limit) {
        const db = this.db.getDb();
        const stmt = db.prepare(`
      SELECT price, timestamp FROM price_data 
      WHERE token_address = ? 
      ORDER BY timestamp DESC 
      LIMIT ?
    `);
        return stmt.all(tokenAddress, limit);
    }
    async calculateTechnicalIndicators(tokenAddress, priceData) {
        // ÁÆÄÂåñÁöÑÊäÄÊúØÊåáÊ†áËÆ°ÁÆó
        const indicators = [];
        if (priceData.length >= 14) {
            // ÁÆÄÂåñÁöÑRSIËÆ°ÁÆó
            const rsi = this.calculateRSI(priceData.slice(0, 14));
            indicators.push({
                tokenAddress,
                indicatorType: 'rsi',
                timeframe: '1h',
                value: rsi,
                signal: rsi > 70 ? 'sell' : rsi < 30 ? 'buy' : 'hold',
                strength: Math.abs(rsi - 50) * 2,
                timestamp: new Date(),
                metadata: { period: 14 }
            });
        }
        return indicators;
    }
    calculateRSI(priceData) {
        // ÁÆÄÂåñÁöÑRSIËÆ°ÁÆó
        let gains = 0;
        let losses = 0;
        for (let i = 1; i < priceData.length; i++) {
            const change = priceData[i - 1].price - priceData[i].price;
            if (change > 0)
                gains += change;
            else
                losses += Math.abs(change);
        }
        const avgGain = gains / (priceData.length - 1);
        const avgLoss = losses / (priceData.length - 1);
        if (avgLoss === 0)
            return 100;
        const rs = avgGain / avgLoss;
        return 100 - (100 / (1 + rs));
    }
    analyzeTrend(priceData) {
        if (priceData.length < 2)
            return 'neutral';
        const recent = priceData.slice(0, 5);
        const older = priceData.slice(5, 10);
        const recentAvg = recent.reduce((sum, d) => sum + d.price, 0) / recent.length;
        const olderAvg = older.reduce((sum, d) => sum + d.price, 0) / older.length;
        const change = (recentAvg - olderAvg) / olderAvg;
        if (change > 0.05)
            return 'bullish';
        if (change < -0.05)
            return 'bearish';
        return 'neutral';
    }
    calculateSupportResistance(priceData) {
        if (priceData.length === 0)
            return { support: 0, resistance: 0 };
        const prices = priceData.map(d => d.price);
        const support = Math.min(...prices);
        const resistance = Math.max(...prices);
        return { support, resistance };
    }
    generateTechnicalSignals(indicators, trend) {
        const signals = [];
        indicators.forEach(indicator => {
            if (indicator.signal === 'buy') {
                signals.push(`${indicator.indicatorType.toUpperCase()} ‰π∞ÂÖ•‰ø°Âè∑`);
            }
            else if (indicator.signal === 'sell') {
                signals.push(`${indicator.indicatorType.toUpperCase()} ÂçñÂá∫‰ø°Âè∑`);
            }
        });
        if (trend === 'bullish') {
            signals.push('‰ª∑Ê†ºË∂ãÂäøÂêë‰∏ä');
        }
        else if (trend === 'bearish') {
            signals.push('‰ª∑Ê†ºË∂ãÂäøÂêë‰∏ã');
        }
        return signals.length > 0 ? signals : ['Êó†ÊòéÊòæÊäÄÊúØ‰ø°Âè∑'];
    }
    calculateTechnicalScore(indicators, trend, signals) {
        let score = 50;
        // Âü∫‰∫éË∂ãÂäø
        if (trend === 'bullish')
            score += 20;
        else if (trend === 'bearish')
            score -= 20;
        // Âü∫‰∫éÊåáÊ†á
        indicators.forEach(indicator => {
            if (indicator.signal === 'buy')
                score += 10;
            else if (indicator.signal === 'sell')
                score -= 10;
        });
        return Math.min(100, Math.max(0, score));
    }
    // ÂÖ∂‰ªñËæÖÂä©ÊñπÊ≥ï...
    async getRecentKOLTransactions(tokenAddress, hours) {
        // ËøôÈáåÂ∫îËØ•Ë∞ÉÁî®KOLËøΩË∏™ÊúçÂä°
        return [];
    }
    analyzeKOLActivity(transactions) {
        if (transactions.length === 0)
            return ['ÊöÇÊó†KOLÊ¥ªÂä®'];
        const buyCount = transactions.filter(tx => tx.action === 'buy').length;
        const sellCount = transactions.filter(tx => tx.action === 'sell').length;
        const activity = [];
        if (buyCount > sellCount) {
            activity.push('KOLÂáÄ‰π∞ÂÖ•');
        }
        else if (sellCount > buyCount) {
            activity.push('KOLÂáÄÂçñÂá∫');
        }
        return activity.length > 0 ? activity : ['KOLÊ¥ªÂä®Âπ≥Ë°°'];
    }
    calculateInfluenceLevel(transactions) {
        const totalValue = transactions.reduce((sum, tx) => sum + (tx.valueSol || 0), 0);
        if (totalValue > 1000)
            return 'high';
        if (totalValue > 100)
            return 'medium';
        return 'low';
    }
    calculateKOLScore(activeKOLs, transactions, influenceLevel) {
        let score = 50;
        score += activeKOLs * 5;
        score += transactions.length * 2;
        if (influenceLevel === 'high')
            score += 20;
        else if (influenceLevel === 'medium')
            score += 10;
        return Math.min(100, Math.max(0, score));
    }
    calculateMarketScore(volume, priceChange, volatility, liquidity) {
        let score = 50;
        // ‰∫§ÊòìÈáèËØÑÂàÜ
        if (volume > 10000)
            score += 20;
        else if (volume > 1000)
            score += 10;
        else if (volume < 100)
            score -= 20;
        // ‰ª∑Ê†ºÂèòÂåñËØÑÂàÜ
        if (priceChange > 0)
            score += Math.min(20, priceChange / 2);
        else
            score += Math.max(-20, priceChange / 2);
        // Ê≥¢Âä®ÁéáËØÑÂàÜÔºàÈÄÇÂ∫¶Ê≥¢Âä®ÊòØÂ•ΩÁöÑÔºâ
        if (volatility > 100)
            score -= 15;
        else if (volatility > 50)
            score -= 5;
        else if (volatility > 10)
            score += 5;
        return Math.min(100, Math.max(0, score));
    }
    getCurrentPrice(tokenAddress) {
        const db = this.db.getDb();
        const stmt = db.prepare(`
      SELECT price FROM price_data 
      WHERE token_address = ? 
      ORDER BY timestamp DESC 
      LIMIT 1
    `);
        const result = stmt.get(tokenAddress);
        return result?.price || 0;
    }
    async getActiveTokens(limit = 20) {
        const db = this.db.getDb();
        try {
            const stmt = db.prepare(`
        SELECT DISTINCT t.address, t.symbol
        FROM tokens t
        LEFT JOIN trading_data td ON t.address = td.token_address
        WHERE td.timestamp > datetime('now', '-24 hours')
        ORDER BY td.volume DESC
        LIMIT ?
      `);
            const rows = stmt.all(limit);
            return rows.map(row => ({ address: row.address, symbol: row.symbol }));
        }
        catch (error) {
            return [];
        }
    }
    async getTokenInfo(tokenAddress) {
        const db = this.db.getDb();
        try {
            const stmt = db.prepare(`
        SELECT symbol, name FROM tokens WHERE address = ?
      `);
            const row = stmt.get(tokenAddress);
            return row ? { symbol: row.symbol, name: row.name } : null;
        }
        catch (error) {
            return null;
        }
    }
    async initializeTechnicalIndicators() {
        // ÂàùÂßãÂåñ‰∏Ä‰∫õÊ®°ÊãüÊäÄÊúØÊåáÊ†áÊï∞ÊçÆ
        logger.info('üìä ÊäÄÊúØÊåáÊ†áÊï∞ÊçÆÂàùÂßãÂåñÂÆåÊàê');
    }
    async checkAnalysisAlerts(analysis) {
        try {
            const alerts = [];
            // È´òÊΩúÂäõÈ¢ÑË≠¶
            if (analysis.potentialScore > 85 && analysis.riskScore < 40) {
                alerts.push(`${analysis.tokenSymbol} ÂèëÁé∞È´òÊΩúÂäõ‰ΩéÈ£éÈô©Êú∫‰ºö`);
            }
            // Âº∫ÁÉà‰π∞ÂÖ•‰ø°Âè∑
            if (analysis.recommendation.action === 'strong_buy' && analysis.recommendation.confidence > 80) {
                alerts.push(`${analysis.tokenSymbol} Âá∫Áé∞Âº∫ÁÉà‰π∞ÂÖ•‰ø°Âè∑`);
            }
            // È´òÈ£éÈô©È¢ÑË≠¶
            if (analysis.riskScore > 80) {
                alerts.push(`${analysis.tokenSymbol} È£éÈô©Á≠âÁ∫ßËæÉÈ´òÔºåËØ∑Ë∞®ÊÖéÊìç‰Ωú`);
            }
            // ÂèëÈÄÅÈ¢ÑË≠¶
            for (const alertMessage of alerts) {
                await this.createAnalysisAlert(analysis.tokenAddress, alertMessage, analysis);
            }
        }
        catch (error) {
            await enhancedErrorHandler.handleError(error, 'checkAnalysisAlerts');
        }
    }
    async createAnalysisAlert(tokenAddress, message, analysis) {
        const db = this.db.getDb();
        try {
            const stmt = db.prepare(`
        INSERT INTO alerts (
          token_address, type, message, severity, data, is_read
        ) VALUES (?, ?, ?, ?, ?, ?)
      `);
            const severity = analysis.riskScore > 80 ? 'high' :
                analysis.potentialScore > 85 ? 'medium' : 'low';
            stmt.run(tokenAddress, 'smart_analysis', message, severity, JSON.stringify({
                overallScore: analysis.overallScore,
                riskScore: analysis.riskScore,
                potentialScore: analysis.potentialScore,
                recommendation: analysis.recommendation.action,
                confidence: analysis.recommendation.confidence
            }), 0);
            // ÂπøÊí≠È¢ÑË≠¶
            if (this.io) {
                this.io.emit('new_alert', {
                    type: 'smart_analysis',
                    message,
                    tokenAddress,
                    tokenSymbol: analysis.tokenSymbol,
                    severity,
                    timestamp: new Date()
                });
            }
            logger.info(`üß† Êô∫ËÉΩÂàÜÊûêÈ¢ÑË≠¶: ${message}`);
        }
        catch (error) {
            await enhancedErrorHandler.handleError(error, 'createAnalysisAlert');
        }
    }
}
//# sourceMappingURL=smart-analyzer.js.map